#  Is Last Character a One-Bit Character? — Full Intuition & C++ Guide

##  Table of Contents

1. [Problem Statement](#problem-statement)
2. [Intuition](#intuition)
3. [C++ Code](#c-code)
4. [Dry Run](#dry-run)
5. [Recommended Video](#recommended-video)

---

##  Problem Statement

Leetcode link: https://leetcode.com/problems/1-bit-and-2-bit-characters/description/

You are given a binary array `bits` representing characters encoded using:

* **1-bit character** → `0`
* **2-bit character** → `10` or `11`

Your task is to determine whether the **last character** must be a **one-bit (0)** character.

---

##  Intuition

The entire problem boils down to **how we move through the array**:

* `0` → represents a **single-bit** character → move **1 step**
* `10` or `11` → represent a **two-bit** character → move **2 steps**

We simply simulate how decoding happens.

---

###  Key Insight

We want to check:
 **Is the final 0 decoded alone?**

Let's understand with examples.

###  Example 1

```
bits = [1,0,0]
```

* `1,0` → forms a **two-bit** character
* Remaining last `0` → must be a **one-bit** character

So output = **true**

###  Example 2

```
bits = [1,0,1,0]
```

* First `1,0` → 2-bit char
* Next `1,0` → 2-bit char
* We never end by decoding the last `0` individually

So output = **false**

---

##  Rules Derived

1. If we see `0` → move **one step**.
2. If we see `1` → move **two steps**.
3. If during a 2-step jump we **land exactly on the last index**, then last char is *not* one-bit → return **false**.
4. If we finish the loop normally → return **true**.

---

##  C++ Code

```cpp
class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int n = bits.size();

        for (int i = 0; i < n; i++) {
            if (bits[i] == 1) {
                // If jumping 2 steps reaches the last index, last char can't be 1-bit
                if (i + 1 == n - 1)
                    return false;

                // Safe 2-step jump
                i++;
            }
        }
        return true;
    }
};
```

---

##  Dry Run

### Example 1:

```
bits = [1,0,0]
n = 3
```

* i = 0 → bits[i] = 1
  * i+1 < n-1 → yes → jump to i = 2

* i = 2 → bits[i] = 0 → skip
* Loop ends → never hit the condition that makes last zero invalid
 Return **true**

---

### Example 2:

```
bits = [1,1,1,0]
n = 4
```

* i = 0 → bits[i] = 1
  * i+1 < n-1 → yes → jump to i = 2

* i = 2 → bits[i] = 1
  * i+1 == n-1 (3 == 3) → true → cannot decode last 0 as one-bit

 Return **false**

---

##  Recommended Video

YouTube Link: https://youtu.be/sHRlVNgUjwA?si=tmZGPE-_ostfdfCj
