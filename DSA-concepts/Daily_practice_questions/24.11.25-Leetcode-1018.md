## Index
1) [Problem Statement](#problem-statement)
2) [Approach](#approach)
3) [Code](#code)
4) [Dry run](#dry-run)
5) [Recommendation](#recommendation)

## Problem Statement

Leetcode link: https://leetcode.com/problems/binary-prefix-divisible-by-5/description/
We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).

For example, if nums = [1,0,1], then x0 = 1 => 1, x1 = 10 => 2, and x2 = 101 => 5.

---

## Approach
**1st concept:** Building the binary number

We are reading bits from left to right (MSB → LSB).

To add a new bit:

Left shift the current number

Then add the new bit

Left shift in binary = multiply by 2 in decimal

Formula:
new_value = (previous_value * 2) + current_bit

**2nd concept :** Avoid large number

The length of nums can go up to 10⁵.

If we keep building the full number, it will become very large and cause overflow.

Key observation:
We only care whether the number is divisible by 5.

So instead of storing the full number, we store only:

remainder = (previous_remainder * 2 + current_bit) % 5

This keeps values small and efficient.

---

## Code

```cpp
class Solution {
public:
    vector<bool> prefixesDivBy5(vector<int>& nums) {
        int i=0,sum=0,n=nums.size();
        vector<bool> res(n,false);
        while(i<n) {
            sum = (2*sum+nums[i])%5;
            if(sum == 0) {
                res[i]=true;
            }
            i++;
        }
        return res;
    }
};
```

---

## Dry Run

Input
nums = [0, 1, 1, 1, 1, 1, 1, 1]

Step-by-step execution
Index (i)	        Calculation	     sum	Divisible by 5	Result
0	  (2×0 + 0) % 5 =   0	          0	           YES	true
1	  (2×0 + 1) % 5 =   1	          1	           NO	false
2	  (2×1 + 1) % 5 =   3	          3	           NO	false
3	  (2×3 + 1) % 5 =   2	          2	           NO	false
4	  (2×2 + 1) % 5 =   0	          0	           YES	true
...	...	...	...	...

---

## Recommendation

YouTube link: https://youtu.be/dRwEixchYqc?si=XDV7Mer2sTNEOCaN