#  Keep Multiplying Found Values by Two â€” Brute Force & Optimized Approaches

##  Table of Contents

1. [Problem Statement](#problem-statement)
2. [Intuition](#intuition)
3. [Brute Force Approach](#brute-force-approach)
4. [Optimized Approach](#optimized-approach)
5. [Dry Run](#dry-run)
6. [Recommended Video](#recommended-video)

---

##  Problem Statement

Leetcode Link: [https://leetcode.com/problems/keep-multiplying-found-values-by-two/description/](https://leetcode.com/problems/keep-multiplying-found-values-by-two/description/)

You are given:

* an integer array `nums`
* an integer `original`

Whenever `original` appears in `nums`, you must replace:

```
original = original * 2
```

and continue checking again.

Return the final value of `original`.

---

## Intuition

### ðŸ”¹ Method 1 â€” Brute Force

Consider:

```
nums = [12, 3, 6, 1, 4], original = 3
```

* When we find `3`, change `original = 6`
* But now `6` appears **later in the array** â†’ we must *re-check entire array*

This means:
 We need **two nested loops** â†’ O(nÂ²)

---

### ðŸ”¹ Method 2 â€” Optimized

If we sort the array:

```
nums = [1, 3, 4, 6, 12], original = 3
```

Now notice:

* After multiplying `original`, it **only increases**
* Sorted order ensures all potential next matches lie **ahead**

Meaning:
 We just traverse once â†’ O(n)

Sorting takes O(n log n), so total time:

```
O(n log n) + O(n)
```

---

##  Brute Force Approach

```cpp
class Solution {
public:
    int findFinalValue(vector<int>& nums, int original) {
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(nums[j] == original)
                    original = original * 2;
            }
        }
        return original;
    }
};
```

**Time Complexity:** O(nÂ²)

---

##  Optimized Approach

```cpp
class Solution {
public:
    int findFinalValue(vector<int>& nums, int original) {
        sort(nums.begin(), nums.end()); // O(n log n)

        for(int num : nums) { // O(n)
            if(num == original)
                original *= 2;
        }
        return original;
    }
};
```

**Time Complexity:** O(n log n) + O(n)

---

##  Dry Run

### Input:

```
nums = [12, 3, 6, 1, 4]
original = 3
```

### After Sorting:

```
nums = [1, 3, 4, 6, 12]
```

| i | nums[i] | original | Action        |
| - | ------- | -------- | ------------- |
| 0 | 1       | 3        | skip          |
| 1 | 3       | 3        | original = 6  |
| 2 | 4       | 6        | skip          |
| 3 | 6       | 6        | original = 12 |
| 4 | 12      | 12       | original = 24 |

 Final output: **24**

---

##  Recommended Video

YouTube link: https://youtu.be/C67GW0rsuDA?si=3H4WlkAvvjg7UYfE
