## Index

1. [Problem Statement](#problem-statement)  
2. [Approach](#Approach)
   - Method 1  
   - Method 2  
3. [Code (Method 1)](#code-method-1) 
4. [Dry Run of Method 1](#dry-run-of-method-1)
5. [Code (Method 2)](#code-method-2)  
6. [Dry Run of Method 2](#dry-run-of-method-2)  
7. [Time Complexity](#time-complexity)  
8. [Recommended Video](#recommended-video)  

# Unique Length-3 Palindromic Sequence

## Problem Statement

LeetCode link:
https://leetcode.com/problems/unique-length-3-palindromic-subsequences/description/

We are given a string and we need to find the number of palindromic subsequences of length 3.

Subsequence means characters taken from the string in order, but not necessarily continuous.

---

## Approach

**Method 1**

We need a palindrome of length 3.
This means:
- First and last characters must be the same
- Middle character can be anything

So the structure is:
x ? x

Example:
s = "abcda"

Take character 'a':
first_index of 'a' = 0
last_index of 'a' = 4

Characters in between:
b, c, d

So possible palindromes are:
aba
aca
ada

---

**Problem with simple counting**

Example:
s = "aaabca"

For character 'a':
first_index = 0
last_index = 5

Characters in between:
a, a, b, c

This gives:
aaa
aaa
aba
aca

But "aaa" appears twice.
We only want UNIQUE palindromes.

---

**Final idea of Method 1**

For each character:
1. Find its first index
2. Find its last index
3. Count how many UNIQUE characters are present between them
4. Each unique middle character forms one unique palindrome

---

**Method 2**

Instead of scanning the string multiple times, we store the first and last index of every character.

We use a vector of size 26.

Let us call it find_index.

Initial state:
find_index = {{-1,-1}, {-1,-1}, {-1,-1}, ... , {-1,-1}}

Mapping:
'a' -> index 0
'b' -> index 1
'c' -> index 2
...

After storing first and last indices, we simply count unique characters between them.

---

## Code (Method 1)

```cpp
class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.size(), count = 0;
        int first_index, last_index;

        unordered_set<char> unique_characters;

        // Example: s = "aabca"
        for (char ch : s) {
            unique_characters.insert(ch);
        }

        for (char ch : unique_characters) {
            first_index = -1;
            last_index = -1;

            for (int i = 0; i < n; i++) {
                if (s[i] == ch) {
                    if (first_index == -1)
                        first_index = i;
                    last_index = i;
                }
            }

            unordered_set<char> st;
            for (int i = first_index + 1; i < last_index; i++) {
                st.insert(s[i]);
            }

            count += st.size();
        }
        return count;
    }
};
```
---

## Dry Run of Method 1

Example:
s = "aaabbccdda"

Unique characters:
a, b, c, d

For character 'a':
first_index = 0
last_index = 9
characters in between = {a, b, c, d}

count = 4

For character 'b':
no characters in between
count = 4

For character 'c':
no characters in between
count = 4

For character 'd':
no characters in between
count = 4

Final answer = 4

---

## Code (Method 2)

class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.size(), count = 0;

        vector<pair<int,int>> find_index(26, {-1, -1});

        for (int i = 0; i < n; i++) {
            int idx = s[i] - 'a';

            if (find_index[idx].first == -1)
                find_index[idx].first = i;

            find_index[idx].second = i;
        }

        for (int i = 0; i < 26; i++) {
            int left_idx = find_index[i].first;
            int right_idx = find_index[i].second;

            unordered_set<char> st;
            for (int j = left_idx + 1; j < right_idx; j++) {
                st.insert(s[j]);
            }

            count += st.size();
        }
        return count;
    }
};

---

## Dry Run of Method 2

s = "aabca"

After first loop:
find_index = {{0,4}, {2,2}, {3,3}, {-1,-1}, ...}

Now for each character:

take first and last index

count unique characters between them

add to answer

---

## Time Complexity

Method 1:
Time Complexity = O(n * 26) = O(n)
Space Complexity = O(1)

Method 2:
Time Complexity = O(n)
Space Complexity = O(26) = O(1)

---

## Recommended Video

YouTube:
https://youtu.be/EdEvy2_o5OE?si=bF-gmreq9F_bVL8N
