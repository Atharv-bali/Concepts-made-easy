## Problem Statement

Leetcode link: https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/description/

You are given an integer array nums and an integer k.

Your task is to find the maximum subarray sum such that the length of the subarray is divisible by k.

## Approach

The subarray length must be k, 2k, 3k, ...

So we can only consider subarrays formed by taking blocks of size k.

This problem is a variation of Kadane’s Algorithm, but applied on chunks of size k instead of single elements.

Input

nums = [-5, 1, 2, -3, 4, 8]
k = 2


Output

15

Intuition

Since k = 2, valid subarray lengths are:

2

4

6

We group elements in blocks of size k:

[-5, 1] | [2, -3] | [4, 8]

Now we apply Kadane’s Algorithm on these blocks:

Keep adding blocks if they increase the sum

Drop previous blocks if they reduce the sum

Example: 

nums=[-5,1,2,-3,4,8], k=2

I started taking elements from index 0

I can take {5,-1}

I can take {2,-3}

I can take {4,8}

I started taking elements from index 1

I can take {-1,2}

I can take {-3,4}

I started taking element from index 2

I take {2,-3}, but this had already been taken, this means that only k-1 index need to be taken after that the index will be repeated.

**I can straight away jump k indexes, as I need subarray whose length is divisible by k**

## Code

```cpp
class Solution {
public:
    long long maxSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<long long> prefSum(n,0);
        prefSum[0]=nums[0];
        for(int i=1;i<n;i++) {
            prefSum[i]=prefSum[i-1]+nums[i];
        }
        long long result=-1e18;
        // loop from 0 to k-1, as after this elements will be repeated
        for(int start=0;start<k;start++) {
            long long currSum=0;
            int i=start;
            while(i<n && i+k-1<n) {
                // jump k index
                int j = i+k-1;
                long long subSum = prefSum[j]-(i>0? prefSum[i-1]:0);
                // apply kadane's algorithm
                currSum = max(subSum+currSum,subSum);
                result = max(currSum,result);
                i+=k;
            }
        }
        return result;
    }
};
```
