## Index
1) [Problem Statement](#problem-statement)
2) [Approach](#approach)
3) [Code](#code)
4) [Dry Run](#dry-run)

## Problem Statement

Leetcode link: https://leetcode.com/problems/smallest-integer-divisible-by-k/description/
You are given an integer k.
You need to find the smallest positive integer that:

contains only digit 1 (like 1, 11, 111, 1111, …)

is divisible by k

Return the length of that number.
If no such number exists, return -1.

## Approach

We keep forming numbers by adding one more 1 at the end:

1 → 11 → 111 → 1111 → ...


We check at which length the number becomes divisible by k.

**Problem with Large Numbers**

If k is large, the number made of many 1s can become too large to store (integer overflow).

**Solution:**

Instead of storing the full number, we only store its remainder modulo k.

**How to Build the Number Using Remainders**

If the current remainder is r, then:

New number = old_number * 10 + 1
New remainder = (r * 10 + 1) % k


So we never store the full number—only the remainder.

**When Do We Stop?**

For any k, there are only k possible remainders:
0, 1, 2, ..., k-1

If after trying k times we never get remainder 0, then:

remainders will start repeating

we will never get a divisible number

So we safely stop after k iterations and return -1.

Example Where Answer Is Impossible (k = 4)
1    % 4 = 1
11   % 4 = 3
111  % 4 = 3
1111 % 4 = 3


Remainders repeat → remainder 0 is never reached → return -1.

## Code

```cpp
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        int sum=0;
        for(int length=1;length<=k;length++) {
            sum = (10*sum+1)%k;
            if(sum==0)
                return length;
        }
        return -1;
    }
};
```

## Dry Run

k=7

Length	Calculation	Remainder
1	(0×10 + 1) % 7 = 1	1
2	(1×10 + 1) % 7 = 4	4
3	(4×10 + 1) % 7 = 6	6
4	(6×10 + 1) % 7 = 5	5
5	(5×10 + 1) % 7 = 2	2
6	(2×10 + 1) % 7 = 0 	0

**Answer = 6**
(Indeed, 111111 % 7 == 0)