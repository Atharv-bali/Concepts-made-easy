## Index

1) [Problem Statement](#problem-statement)  
2) [Approach](#approach)  
3) [Code](#code) 
4) [Dry Run](#dry-run) 
4) [Recommended Video](#recommended-video)

---

## Problem Statement

LeetCode Link:  
https://leetcode.com/problems/greatest-sum-divisible-by-three/description/

We are given an array of numbers.  
We need to find the **maximum possible sum** such that the sum is **divisible by 3**.

We are allowed to:
- take any elements
- skip any elements

---

## Approach

**Method 1 (Greedy Logic)**

1. First, calculate the **sum of all numbers**.
2. Check if the sum is divisible by 3.
   - If yes, return the sum.
3. If not, then the remainder when divided by 3 can be **1 or 2**.

---

**Case 1: Sum % 3 == 1**

To make the sum divisible by 3, we can:
- remove **one number** whose remainder is `1`
OR
- remove **two numbers** whose remainder is `2`

We must choose the option that removes the **smallest total value**, so the remaining sum is maximum.

**Why not always remove remainder 1 directly?**

Example:

For example: nums=[3,2,16,13,19,8]
sum=61, remainder comes 1
remain1=[13,16,19]
remain2=[2,5,8]
If I remove remain1's first element, sum=61-13=48
If I remove remain2's first two elements, sum=61-7=54
Therefore I can get a greater number by removing 2 elements of remiander 2.
--> If I get remainder as 2, I can either remove a number that contains remainder 2 or I can remove 2 number that contains remainder 1.

**Method-2** (Top-down)

We need to find **maximum possible sum**, we can take any element and can also leave any element that we want, so question points to DP.
Let's first think of a base condition,
--> If remainder becomes 0, we can take that sum.
--> If remainder is not zero, we will not take that sum, for maximum we will return INT_MIN.
Main logic
We have 2 option, first to take the sum, another to  skip it
Then convert this recursion into memoization

**Method-3** (Bottom-up)

--> We will derive from Method-2.

---

## Code
**Method-1**
```cpp
class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        int sum = 0;
        vector<int> remain1, remain2;

        for (int num : nums) {
            sum += num;
            
            if (num % 3 == 1)
                remain1.push_back(num);
            else if (num % 3 == 2) 
                remain2.push_back(num);
        }

        if (sum % 3 == 0) 
            return sum;

        sort(begin(remain1), end(remain1));
        sort(begin(remain2), end(remain2));

        int result = 0;
        //anything % 3 can only be 0 or 1 or 2

        if (sum % 3 == 1) {
            int remove1 = remain1.size() >= 1 ? remain1[0] : INT_MAX;
            int remove2 = remain2.size() >= 2 ? remain2[0] + remain2[1] : INT_MAX;
            result      = sum - min(remove1, remove2);
        } 
        else { // sum % 3 == 2
            int remove1 = remain2.size() >= 1 ? remain2[0] : INT_MAX;
            int remove2 = remain1.size() >= 2 ? remain1[0] + remain1[1] : INT_MAX;
            result      = sum - min(remove1, remove2);
        }

        return result;
    }
};
```

**Method-2**

```cpp
class Solution {
public:
    int solve(int i, int remain, vector<int> &nums, vector<vector<int>>& dp) {
        if(i>=nums.size()) {
            if(remain == 0)
                return 0;
            return -1e9;
        }
        if(dp[i][remain%3]!=-1)
            return dp[i][remain];
        // main logic line
        int take = nums[i]+solve(i+1,(remain+nums[i])%3,nums,dp);
        int skip = solve(i+1,remain,nums,dp);
        return dp[i][remain]=max(skip,take);
    }
    int maxSumDivThree(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n,vector<int>(3,-1));
        return solve(0,0,nums,dp);
    }
};
```

**Method-3**

--> In base condition we can say that for i=n, if we get remainder as 0, then we need to have 0, other wise -1e9, therefore this step
dp[n][1]=-1e9;
dp[n][2]=-1e9;
--> In recursion the i value is going from 0 to n-1, so in tabulation we will go from n-1 to 0
--> Copy the main logic line, change solve to dp
```cpp
class Solution {
public:
    // int solve(int i, int remain, vector<int> &nums, vector<vector<int>>& dp) {
    //     if(i>=nums.size()) {
    //         if(remain == 0)
    //             return 0;
    //         return -1e9;
    //     }
    //     if(dp[i][remain%3]!=-1)
    //         return dp[i][remain];
    //     // main logic line
    //     int take = nums[i]+solve(i+1,(remain+nums[i])%3,nums,dp);
    //     int skip = solve(i+1,remain,nums,dp);
    //     return dp[i][remain]=max(skip,take);
    // }
    int maxSumDivThree(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n+1,vector<int>(3,0));
        dp[n][1]=-1e9;
        dp[n][2]=-1e9;
        for(int i=n-1;i>=0;i--) {
            for(int remain=0;remain<=2;remain++) {
                //Copy everything from main logic line and just write dp instead of solve, and other changes wrt to it.
                int take = nums[i]+dp[i+1][(remain+nums[i])%3];
                int skip = dp[i+1][remain];
                dp[i][remain]=max(skip,take);
            }
        }
        return dp[0][0];
    }
};
```
---

## Dry Run

Example: nums=[3,2,16,13,19,8]
sum=0,remain1=[],remain2=[]

After for each loop
sum=61%3=1
remain1=[16,13,19]
remain2=[2,8]
now sort both
remain1=[13,16,19]
remain2=[2,8]

remove1=remain1[0]=13
remove2=remain2[0]+remain2[1]=2+8=10
result=sum-min(remove1,remove2)=61-min(13,10)
result=61-10=51
This sum will be returned.

---

## Recommended Video
You Tube: https://youtu.be/bKbLIDzLiGQ?si=9nDz-D_vEM1zAA3O
