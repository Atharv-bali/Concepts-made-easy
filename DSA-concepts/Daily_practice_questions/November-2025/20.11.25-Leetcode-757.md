#  Set Intersection Size at Least Two — Clean Intuition & C++ Solution

##  Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Code](#code)
4. [Dry Run](#dry-run)
5. [Recommended Video](#recommended-video)

---

##  Problem Statement

Leetcode link: [https://leetcode.com/problems/set-intersection-size-at-least-two/description/](https://leetcode.com/problems/set-intersection-size-at-least-two/description/)

You are given a list of intervals. Your goal is to choose **the minimum number of integers** such that **each interval contains at least two** of the chosen integers.

---

##  Approach

This is a **classic greedy + sorting** problem.

To ensure each interval has **at least two selected numbers**, we must:

* Always try to reuse previously selected numbers.
* Only add new numbers when necessary.
* Process intervals in the correct order.

---

###  Why Sorting Is Needed

Consider intervals:

```
[1,3], [3,7]
```

If we select numbers `{2,3}`, then:

* `[1,3]` contains `{2,3}`
* `[3,7]` contains `{3}` → needs one more → select `4`
Therefore we will take the element as last as possible of the number always as it can get included in the side index also, thus shortening the length of result vector

But what if intervals are:

```
[1,3], [3,7], [5,7]
```

If sorted only by ending points:

```
[1,3], [3,7], [5,7]   WRONG ORDER
```

This causes incorrect selection.

###  Correct Sorting Strategy

Sort intervals by:

1. **End point** (ascending)
2. If end points are equal → sort by **start point** (descending)

Why descending start point?

* Among intervals with same ending, the one starting later is **more restrictive**.
* Processing restrictive intervals first reduces unnecessary selections.

---

##  Greedy Logic

For each interval `[l, r]`, we maintain:

* `first` → the **largest** selected number so far
* `second` → the **second largest** selected number

For each interval we check:

### **Case 1 — Full Overlap (`l ≤ first`)**

The interval already has **two** selected numbers → no need to add anything.

### **Case 2 — No Overlap (`l > second`)**

This interval has **zero** selected numbers → we must add two:

```
Add (r-1) and r
```

Update:

```
first = r-1
second = r
result += 2
```

### **Case 3 — Partial Overlap (`l ≤ second < first`)**

This interval has **one** selected number → we add **one more**:

```
Add r
Update second = r
result += 1
```

---

##  Code

```cpp
class Solution {
public:

    static bool comp(const vector<int> &a, const vector<int> &b) {
        if (a[1] != b[1])
            return a[1] < b[1];
        return a[0] > b[0];
    }

    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), comp);

        int first = -1, second = -1;
        int result = 0;

        for (auto &it : intervals) {
            int l = it[0];
            int r = it[1];

            // Case 1: Already has two numbers
            if (l <= first) {
                continue;
            }

            // Case 2: No overlap → need two numbers
            if (l > second) {
                result += 2;
                first = r - 1;
                second = r;
            }
            // Case 3: One overlap → need one number
            else {
                result += 1;
                first = second;
                second = r;
            }
        }
        return result;
    }
};
```

---

##  Dry Run

### Example:

```
Intervals = [[1,3], [3,7], [8,9]]
```

Initial values:

```
first = -1
second = -1
result = 0
```

### i = 0 → [1,3]

```
l = 1, r = 3
No overlap → add 2 numbers: {2, 3}
first = 2
second = 3
result = 2
```

### i = 1 → [3,7]

```
l = 3, r = 7
Partial overlap → only one number (3) is inside
Add r → add {7}
first = 3
second = 7
result = 3
```

### i = 2 → [8,9]

```
l = 8, r = 9
No overlap → add {8, 9}
first = 8
second = 9
result = 5
```

Final Answer = **5**

---

## Recommended Video
You Tube link: https://youtu.be/vkFaZIgO10Y?si=ADcPb6_0oEKb0jMC