#  Count Substrings With Only '1's — Brute Force & Optimized Approaches

##  Table of Contents

1. [Problem Statement](#problem-statement)
2. [Brute Force](#brute-force)
3. [Logic](#logic)
4. [Optimized Approach](#optimized-approach)
5. [Recommended Video](#recommended-video)

---

##  Problem Statement

Leetcode Link: https://leetcode.com/problems/number-of-substrings-with-only-1s/description/

You are given a binary string `s`. Your task is to count how many **substrings contain only '1's**.

Since the answer may be large, return it **modulo 1e9+7**.

---

##  Brute Force 

Whenever we talk about **substrings**, the most basic brute-force pattern is:

```
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        // logic
    }
}
```

###  Logic

We only count substrings made up of **consecutive '1's**.

Let’s analyze how many substrings are possible:

```
1     → 1 substring
11    → 1, 1, 11 → 3 substrings
111   → 1,1,1,11,11,111 → 6 substrings
```

Which follows:

```
Length 1 → 1        → 1
Length 2 → 1 + 2    → 3
Length 3 → 1 + 2 + 3 → 6
...
```

That means:

```
For a streak of k consecutive ones → total substrings = 1 + 2 + … + k = k*(k+1)/2
```

###  Example: `101101`

At position `i = 2` and `j = 2`:

```
total += (j - i + 1) → +1
```

At `j = 3` now we have "11":

```
(j - i + 1) = 2 → +2
Running total becomes 3
```

###  C++ Code

```cpp
class Solution {
public:

    int MOD = 1e9+7;

    int numSub(string s) {
        int total = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {
            if (s[i] == '0') continue;

            for (int j = i; j < n; j++) {
                if (s[j] == '0') break;

                total = (total + (j - i + 1)) % MOD;
            }
        }
        return total;
    }
};
```

###  Dry Run (101101)

```
total = 0

i = 0 → j = 0 → total = 1
j = 1 → break

i = 1 → skip

i = 2 → j = 2 → total = 2
j = 3 → total = 4
j = 4 → break

i = 3 → j = 3 → total = 5
j = 4 → break

i = 4 → skip

i = 5 → j = 5 → total = 6
```

---

##  Optimized Approach 

Instead of iterating repeatedly, we count **consecutive '1's** directly.

###  Key Idea

* Reset counter whenever we see `'0'`.
* When we see `'1'` → increment counter.
* Add that counter to total.

This works because:

```
For streak: 1 → +1
For streak: 11 → +1 +2
For streak: 111 → +1 +2 +3
```

Exactly the same pattern as brute force, but linear.

###  C++ Code

```cpp
class Solution {
public:

    int MOD = 1e9+7;

    int numSub(string s) {
        int total = 0, count = 0;

        for (char ch : s) {
            if (ch == '0') {
                count = 0;
            }
            else {
                count++;
                total = (total + count) % MOD;
            }
        }
        return total;
    }
};
```

###  Dry Run (101101)

```
count=0, total=0

1 → count=1 → total=1
0 → count=0
1 → count=1 → total=2
1 → count=2 → total=4
0 → count=0
1 → count=1 → total=5
```

Final answer = **5**

---

##  Recommended Video

YouTube Link: [https://youtu.be/JvLxk7KFKUQ?si=iSFb8Hj1PxJiqJLA](https://youtu.be/JvLxk7KFKUQ?si=iSFb8Hj1PxJiqJLA)
