##  Table of Contents
- [Problem Statement](#problem-statement)
- [Method 1: Brute Force (O(n¬≥))](#method-1-brute-force-on)
- [Method 2: Prefix Sum Optimization (O(n¬≤))](#method-2-prefix-sum-optimization-on)
- [Method 3: Jump Optimization (~O(n‚àön))](#method-3-jump-optimization-onn)
- [Final Complexity Comparison](#final-complexity-comparison)
- [Recommended Video](#recommended-video)

## Problem Statement
Leetcode link: https://leetcode.com/problems/count-the-number-of-substrings-with-dominant-ones/description/

PrefixSum link: https://github.com/Atharv-bali/Concepts-made-easy/tree/main/DSA-concepts/Daily_practice_questions/PrefixSum

## Method 1: Brute Force (O(n¬≥))


class Solution {

public:
    int numberOfSubstrings(string s) {
    
        /* --------------------------------------------------------------------
           METHOD 1: Pure Brute Force  ‚Äî O(n¬≥)
           --------------------------------------------------------------------
           Idea:
           ‚Ä¢ Generate every possible substring s[i..j].
           ‚Ä¢ Inside each substring, count zeros and ones manually.
           ‚Ä¢ Check the condition:  (zero * zero) <= one.

           Why is this slow?
           ‚Ä¢ Three nested loops:
                i ‚Üí O(n)
                j ‚Üí O(n)
                k ‚Üí O(n)
             Total = O(n¬≥)

           This method helps us understand the problem but will Exceed the Time Limit.
        -------------------------------------------------------------------- */

        int n = s.size(), result = 0;

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {

                int zero = 0, one = 0;

                for (int k = i; k <= j; k++) {
                    if (s[k] == '0') zero++;
                    else one++;
                }

                if (zero * zero <= one)
                    result++;
            }
        }

        // return result;   // (Commented so Method 2 can execute below)
    }
    

## Method 2: Prefix Sum Optimization (O(n¬≤))


        /* --------------------------------------------------------------------
           METHOD 2: Using Prefix Sum  ‚Äî O(n¬≤)
           --------------------------------------------------------------------
           Why do we use prefix sum?
           ‚Ä¢ Inside every substring s[i..j], counting ones repeatedly is expensive.
           ‚Ä¢ Prefix sum lets us find number of ones in O(1):
                 ones(i..j) = prefix[j] - prefix[i-1]
           ‚Ä¢ Then zeros = (substring length) - ones

           Example:
           s = 101101
           ones(1..4) = prefix[4] - prefix[0]

           This reduces time complexity from O(n¬≥) ‚Üí O(n¬≤).
        -------------------------------------------------------------------- */

        int result = 0;
        vector<int> prefix(n, 0);

        prefix[0] = (s[0] == '1');
        for (int i = 1; i < n; i++)
            prefix[i] = prefix[i - 1] + (s[i] == '1');

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {

                int one = prefix[j] - (i > 0 ? prefix[i - 1] : 0);
                int zero = (j - i + 1) - one;

                if (zero * zero <= one)
                    result++;
            }
        }

        // return result;   // (Commented so Method 3 can run)
    }
        

## Method 3: Jump Optimization (~On‚àön)


        /* --------------------------------------------------------------------
           METHOD 3: Optimized Jump Method ‚Äî approx O(n ‚àön)
           --------------------------------------------------------------------
           Goal:
           ‚Ä¢ Reduce the j-loop further by jumping over impossible ranges.
           ‚Ä¢ Use math to skip many j positions at once.

           Key Insight:
           Condition: zero¬≤ <= one

           For every (i, j), three cases occur:
           
           CASE 1: zero¬≤ > one ‚Üí need more ones ‚Üí jump  
           CASE 2: zero¬≤ == one ‚Üí valid (count)  
           CASE 3: zero¬≤ < one ‚Üí valid and can skip ahead  
        -------------------------------------------------------------------- */

        int result = 0;
        vector<int> cumCountOne(n, 0);

        cumCountOne[0] = (s[0] == '1');
        for (int i = 1; i < n; i++)
            cumCountOne[i] = cumCountOne[i - 1] + (s[i] == '1');

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {

                int countOne = cumCountOne[j] - (i > 0 ? cumCountOne[i - 1] : 0);
                int countZero = (j - i + 1) - countOne;

                // CASE 1: Need more ones ‚Üí jump
                if (countZero * countZero > countOne) {
                    int need = (countZero * countZero) - countOne;
                    j += need - 1;
                }
                // CASE 2: Perfect balance
                else if (countZero * countZero == countOne) {
                    result++;
                }
                // CASE 3: Enough ones ‚Üí jump ahead
                else {
                    result++;

                    int k = sqrt(countOne) - countZero;

                    if (j + k >= n) {
                        result += (n - j - 1);
                        break;
                    }
                    else {
                        result += k;
                        j += k;
                    }
                }
            }
        }

        return result;
    }
    
};

## Final Complexity Comparison

Method	Time Complexity	Status

Brute Force	O(n¬≥)	‚ùå Too slow

Prefix Sum	O(n¬≤)	‚úÖ Good

Jump Method	~O(n ‚àön)	üöÄ Best


## Recommended Video

YouTube link: https://youtu.be/gWRnztyET8s?si=SoSnL7TUqBbTpE5q
